// This bundle was auto-generated on 2021-4-8 at 16:39:36
// From the folders: 
// /home/xgbsesvc/jenkins/jenkins/workspace/sysconfig.build.installers/pinmux/out/dist/deviceData/F2833x
defineResource("/F2833x/templates/bitfield/f2833x_pinmux.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    var date = new Date();

    var maxGpioNumber = _.chain( deviceData.devicePins )
        .map( "designSignalName" )
        .map( function( name ) { return parseInt( name.substr( 4 ) ); } )
        .max()
        .value()

    var maxPortIndex = Math.floor( parseInt( maxGpioNumber ) / 32 );

    var portIndices = _.take( [ "A", "B", "C", "D", "E", "F" ], maxPortIndex + 1 );

    // Make sure we don't get any writes to a MUX2 reg that doesn't exist
    var needMUX2ForLastPort = true;
    if( (maxGpioNumber % 32) < 16 ) {
        needMUX2ForLastPort = false;
    }

    var xbarPresent = [];
    _.times( 16, function() {
        xbarPresent.push( false );
    } );

    _.each( assignments, function( assignment ) {
        if (/XBAR/.test(assignment.muxMode) == true) {
            xbarPresent[parseInt( assignment.muxMode.substr( 4 ) ) - 1] = true;
        }
    } );

;
__p += '//*****************************************************************************\n//\n// f2833x_pinmux.c - Function to write the generated pin mux values to the\n//                   appropriate registers.\n// Created using TI Pinmux ' +
((__t = (version)) == null ? '' : __t) +
' on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n//\n//*****************************************************************************\n//\n// Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//   Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n//\n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the\n//   distribution.\n//\n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n//\n// NOTE!! This file uses bit field structures and macros from C2000Ware.\n// This function is provided for your convenience and to serve as an example\n// of the use of the generated header file, but its use is not required.\n//\n// To download C2000Ware:  http://www.ti.com/tool/C2000Ware\n//\n//*****************************************************************************\n\n#include "DSP28x_Project.h"\n#include "f2833x_pinmux.h"\n\n//*****************************************************************************\n//\n// Configures the pin mux registers, using the generated register values.\n//\n// This function writes the values generated by the pin mux tool to their\n// corresponding GPIO control registers. These generated values should be found\n// in the generated "f2833x_pinmux.h."\n//\n//*****************************************************************************\nvoid\nGPIO_setPinMuxConfig(void)\n{\n    EALLOW;\n\n    //\n    // Clear the mux register fields that are about to be changed\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1.all	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_MASK;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2.all	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_MASK;\n';
   }
 } )
;
__p += '\n    //\n    // Write pin muxing to mux registers\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1.all	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_VALUE;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2.all	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_VALUE;\n';
   }
 } )
;
__p += '\n    EDIS;\n}\n';
return __p
}; });
defineResource("/F2833x/templates/bitfield/f2833x_pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    var date = new Date();

    var maxGpioNumber = _.chain( deviceData.devicePins )
        .map( "designSignalName" )
        .map( function( name ) { return parseInt( name.substr( 4 ) ); } )
        .max()
        .value()

    var maxPortIndex = Math.floor( parseInt( maxGpioNumber ) / 32 );

    var possibleIndices = [ "A", "B", "C", "D", "E", "F", "G", "H" ];
    var portIndices = _.take( possibleIndices, maxPortIndex + 1 );

    // Make sure we don't get any defines for a MUX2 reg that doesn't exist
    var needMUX2ForLastPort = true;
    if( (maxGpioNumber % 32) < 16 ) {
        needMUX2ForLastPort = false;
    }

    // Variables for normal GPIO
    var muxValues = [];
    var comments = [];
    var muxMasks = [];

    _.times( portIndices.length, function() {
        muxValues.push( [ [ 0, 0 ], [ 0, 0 ] ] );
        comments.push( [] );
        muxMasks.push( [ 0, 0 ] );
    } );

    // Loop through all assignments made by the solver
    _.each( assignments, function( assignment ) {

        // Extract the GPIO number for the pin that was chosen
        var gpioNumber = parseInt( assignment.devicePin.designSignalName.substr( 4 ) );

        // Calculate which port the GPIO is on
        var portIndex = Math.floor( gpioNumber / 32 );

        // Calculate the shift amount to get the mux mode value into the right
        // field in the register. Remember there are 16 GPIOs per register and
        // they each get two bits.
        var shiftAmount = (gpioNumber % 16) * 2;

        // Is the GPIO configured in MUX1 or MUX2?
        var regNumber = ( ( gpioNumber % 32 ) < 16 ) ? 0 : 1;

        if(assignment.muxMode == "ALT") {
            // A mux mode of ALT means to leave the mux value as 0
            var muxMode = 0;
        } else if (/ALT[0-9]/.test(assignment.muxMode)) {
            // Some muxModes are identified by ALTx where x is the muxMode
            var muxMode = parseInt( assignment.muxMode.substr( 3 ) );
        } else {
            // Normal muxMode
            muxMode = assignment.muxMode & 0x3;
        }

        // Calculate value for the GPnMUX#_VALUE #defines.
        // Shift each GPIO's mux mode value into place and OR it in.
        muxValues[ portIndex ][ regNumber ][ 0 ] = ( muxValues[ portIndex ][ regNumber ][ 0 ] | ( ( muxMode ) << shiftAmount ) ) >>> 0;
        comments[ portIndex ].push( "// Pin " + assignment.devicePin.ball + " " +
            "(" + assignment.devicePin.designSignalName + ") " +
            "to " + assignment.peripheralPin.name + " " +
            "(mode " + assignment.muxMode + ")" );
        muxMasks[ portIndex ][ regNumber ] = ( muxMasks[ portIndex ][ regNumber ] | ( 0x3 << shiftAmount ) ) >>> 0;

    } );

    var toPaddedHex = function( value ) {
        var unPadded = ( value ).toString( 16 );
        var passing = "0x00000000";
        return passing.substr( 0, passing.length - unPadded.length ) + unPadded;
    };

    var poundDefineMask = function( portIndex, registerIndex ) {
        return "GP" + portIndices[ portIndex ] + "MUX" + ( registerIndex + 1 ) + "_MASK";
    };

    var poundDefineName = function( portIndex, registerIndex, isGroup ) {
        return "GP" + portIndices[ portIndex ] + ( ( isGroup === 1 ) ? "G" : "" ) +
            "MUX" + ( registerIndex + 1 ) + "_VALUE";
    };

;
__p += '//*****************************************************************************\n//\n//  f2833x_pinmux.h - Created using TI Pinmux ' +
((__t = (version)) == null ? '' : __t) +
' on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n//\n//*****************************************************************************\n//\n// Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//   Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n//\n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the\n//   distribution.\n//\n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n//\n//  These values will provide the functionality requested when written into\n//  the registers for which the #defines are named.  For example, using the\n//  C2000Ware device support header files, use the defines like in this\n//  sample function:\n//\n//  void samplePinMuxFxn(void)\n//  {\n//      EALLOW;\n//      //\n//      // Write generated values to mux registers\n//      //\n//      GpioCtrlRegs.GPAMUX1.all  = GPAMUX1_VALUE;\n//      GpioCtrlRegs.GPAMUX2.all  = GPAMUX2_VALUE;\n//      GpioCtrlRegs.GPBMUX1.all  = GPBMUX1_VALUE;\n//        . . .\n//      EDIS;\n//  }\n//\n//*****************************************************************************\n';
 for( var portIndex = 0; portIndex < portIndices.length; ++portIndex ) {
;
__p += '\n//\n// Port ' +
((__t = (portIndices[ portIndex ])) == null ? '' : __t) +
' mux register values\n//\n';
   _.each( comments[ portIndex ], function( comment ) {
;
__p +=
((__t = (comment)) == null ? '' : __t) +
'\n';
   } );
;
__p += '#define ' +
((__t = (poundDefineMask( portIndex, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxMasks[ portIndex ][ 0 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineMask( portIndex, 1 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxMasks[ portIndex ][ 1 ] ))) == null ? '' : __t) +
'\n';
   }
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 0, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 0 ][ 0 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 1, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 1 ][ 0 ] ))) == null ? '' : __t) +
'\n';
   }
 }
;
__p += '\n//*****************************************************************************\n//\n// Function prototype for function to write values above into their\n// corresponding registers. This function is found in f2833x_pinmux.c. Its use\n// is completely optional.\n//\n//*****************************************************************************\nextern void GPIO_setPinMuxConfig(void);\n';
return __p
}; });
defineResource("/F2833x/templates/csv/PinmuxConfigSummary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;
;
__p += 'Design Signal Pad Name,Ball Name,Selected Mode Number,Mode Interface Name,Mode Signal Name,User Requirement Name\n';
 for( var i = 0; i < assignments.length; ++i ) {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (assignments[i].muxMode)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheral.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\n';
 }
;

return __p
}; });